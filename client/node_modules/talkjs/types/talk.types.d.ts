/**
 * App metadata, such as global custom fields for the entire app.
 *
 * @public
 */
declare interface AppMetadata {
    readonly id: string;
    readonly custom: CustomData;
}

/**
 * @public
 * @hidden due to being empty
 */
export declare interface BlurEvent {
}

/**
 * A messaging UI for just a single conversation
 *
 * @remarks
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Chatbox.select}).
 * Create a Chatbox through {@link Session.createChatbox} and then call
 * {@link Chatbox.mount} to show it.
 * @public
 */
export declare interface Chatbox extends UIBox {
    /**
     * Renders the Chatbox UI inside a DOM element on your page.
     *
     * @remarks
     * The container element specified by `container` must either be a DOM Element (as returned by e.g.
     * `document.getElementById`) or a JQuery object with a single element.
     */
    mount(container: HTMLElement | JQuery | null): Promise<void>;
    /**
     * Destroys the chatbox and removes it from the DOM
     *
     * @remarks
     * Destroys the chatbox, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the chatbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Chatbox
 * @public
 */
export declare interface ChatboxOptions {
    /**
     * Controls the text direction (for supporting right-to-left languages such as Arabic and Hebrew). TalkJS tries
     * to determine the appropriate text direction from the parent page, but if that does not work or you want to
     * explicitly control it, you can override it here. Defaults to "rtl".
     */
    dir?: "rtl" | "ltr";
    /**
     * Sets the message input box to the given text.
     * You can use this to suggest a certain initial message to be sent. The user can still edit it before hitting "send".
     *
     * @deprecated We recommend using {@link MessageField.setText} before mounting the chatbox to precisely control when message suggestions are shown.
     */
    messageSuggestion?: string;
    /**
     * Used to control if the Chat Header is displayed in the UI. Defaults to true.
     */
    showChatHeader?: boolean;
    /**
     * Controls what text appears in the chat title, in the header above the messages.
     * Defaults to `"participants"`.
     *
     * (also see {@link this.chatSubtitleMode} and {@link InboxOptions.feedConversationTitleMode})
     */
    chatTitleMode?: "subject" | "participants";
    /**
     * Controls what text appears in the chat subtitle, right below the chat title.
     * No subtitle is displayed when the conversation has no subject set or when set to `null`.
     * Defaults to `"subject"`.
     *
     * (also see {@link this.chatTitleMode} and {@link InboxOptions.feedConversationTitleMode})
     */
    chatSubtitleMode?: "subject" | "participants" | null;
    /**
     * TalkJS leverages `iframe`s behind the scenes and therefore not all services that you use in your app will work out of the box.
     * This option adds support for a number of services to help you use them. Let us know if you're missing any.
     */
    thirdparties?: ThirdPartyOptions;
    /**
     * Used to control which messages are shown in the message list, depending on a type, origin
     * or custom message attributes.
     *
     * *Note*: Messages are only filtered in the message list. The inbox UI's conversation feed will always show the last message sent to the conversation, regardless of the message filter set.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link UIBox.setMessageFilter}.
     */
    messageFilter?: MessagePredicate;
    /**
     * TalkJS can translate conversations to the current user's locale using Google Translate.
     * This option specifies which conversations should be translated in this UI. You can pass a boolean to enable/disable
     * translation for all conversations, "auto" to enable translation on conversations where users have different locales,
     * or you can pass an array of {@link ConversationBuilder}s or conversation Ids to be translated.
     * This feature is only available on the Growth plan and above. Make sure you add your Google Translate API key in the dashboard.
     */
    translateConversations?: boolean | "auto" | string[] | ConversationBuilder[];
    /**
     * Set this to `true` to show a translation toggle in all conversations.
     * Set this to `"auto"` to show a translation toggle in conversations where there are participants with different locales.
     * This setting defaults to `false`, meaning that no toggles will be shown.
     * In order to use this, you must be on the Growth plan, and set a Google Translate API key in the dashboard.
     */
    showTranslationToggle?: boolean | "auto";
    /**
     * Settings that affect the behavior of the message field
     */
    messageField?: MessageFieldOptions;
    /**
     * Overrides the theme used for this chat UI.
     *
     * @remarks
     * This only works with themes created in the Theme Editor.
     *
     * If you omit this field, the UI uses the theme that is selected in the current user's role.
     */
    theme?: string;
    /**
     * Enables capturing {@link Chatbox.on__keyup__ | on("keyup")} events.
     *
     * @remarks
     * Note: Setting this to true also disables any non-standard keyboard shortcuts in TalkJS.
     *
     * At the time of writing, the only such shortcut is that when `captureKeyboardEvents` is
     * disabled, TalkJS will auto-focus the message field if the user starts typing but no input field
     * is focused.
     */
    captureKeyboardEvents?: boolean;
}

/** @public
 * @hidden due to being empty
 */
declare interface CloseEvent_2 {
}
export { CloseEvent_2 as CloseEvent }

/**
 * Encapsulates an active conversation between two parties.
 *
 * @remarks
 * Use this object to send system messages to the conversation or to programmatically select a
 * conversation by passing it to {@link Inbox.select}.
 *
 * Conversation objects are created with the deprecated {@link Session.getOrStartConversation}
 * method.
 *
 *
 * @public
 * @deprecated
 */
export declare interface Conversation {
    /**
     * The ID of the conversation
     */
    readonly id: string;
    /**
     * @hidden
     * An array of {@link Participant | Participants} in the conversation.
     */
    participants: Array<Participant>;
    /**
     * Legacy - please use {@link Conversation.subject} instead.
     */
    readonly topicId?: string;
    /**
     * An optional conversation subject which is displayed in the chat header
     */
    subject?: string | null;
    /**
     * Optional custom conversation meta data
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    welcomeMessages?: Array<string> | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.
     */
    photoUrl?: string | null;
}

/** @public */
export declare type ConversationAccessLevel = "ReadWrite" | "Read" | "None";

/**
 * Conversation attributes that can be set using {@link ConversationBuilder.setAttributes}
 * @public
 */
export declare interface ConversationAttributes {
    /**
     * A human-readable subject of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://example.com/booking/18644|home by the sea>!`.
     *  URLs and email addresses are made clickable, and emojis made to work cross-platform.
     */
    subject?: string | null;
    /**
     * The URL of a photo to be used for this conversation in the TalkJS UI in case there are more than 2 participants
     * (TalkJS shows the photo of the other participant in a 1-on-1 conversation)
     */
    photoUrl?: string | null;
    /**
     * Custom metadata that is stored with the conversation
     */
    custom?: {
        [key: string]: string | null;
    } | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     */
    welcomeMessages?: Array<string> | null;
}

/**
 * A Conversation Builder represents a conversation that is about to be created, fetched, or updated.
 * You can use this object to set up or modify a conversation before showing it.
 *
 * Note: any changes you make here will not be sent to TalkJS immediately.
 * Instead, instantiate a TalkJS UI using methods such as {@link Session.createInbox}.
 *
 * @public
 */
export declare interface ConversationBuilder {
    /**
     * An optional conversation subject which will be displayed in the chat header.
     */
    subject?: string | null;
    /**
     * Allows custom conversation metadata to be stored in the form `{ [name: string]: string }`
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.
     */
    photoUrl?: string | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     */
    welcomeMessages?: Array<string> | null;
    /**
     * Sets a participant of the conversation.
     *
     * @remarks
     * This method is idempotent and can be called multiple times.
     *
     * @param user - A `User` object that identifies the person who is a participant of the
     * conversation. The user is uniquely identified by their id; all other fields (name, photo etc)
     * are overwritten in the TalkJS database each  time they change.
     * @param settings - An optional setting of participation, can be an initial `access` right or
     * if user should be notified.
     */
    setParticipant(user: User, settings?: Partial<ParticipationSettings>): void;
    /**
     * Used to set certain attributes for a specific conversation
     *
     * @remarks
     * For example:
     *
     * ```
     * conversation.setAttributes({subject: "Booking question"});
     * conversation.setAttributes({custom:
     *   {
     *     sold: "true",
     *     itemId: "720"
     *   }
     * });
     *
     * ```
     *
     */
    setAttributes(attributes: ConversationAttributes): void;
    /**
     * Sends a text message in a given conversation.
     * @param text - The message body that is to be sent.
     */
    sendMessage(text: string, options?: SendMessageOptions): Promise<void>;
}

/** @public */
export declare interface ConversationData {
    /**
     * The ID of the conversation
     */
    id: string;
    /**
     * Contains custom metadata for the conversation if it was set using {@link ConversationBuilder.custom}.
     */
    custom: CustomData;
    /**
     * Contains the conversation subject if it was set using {@link ConversationBuilder.subject}.
     */
    subject: string | null;
    /**
     * @deprecated
     * Please use {@link ConversationBuilder.subject} instead.
     */
    topicId: string | null;
    /**
     * Contains the URL of a photo was set using {@link ConversationBuilder.subject}.
     */
    photoUrl: string | null;
    /**
     * One or more welcome messages that will display to the user as a SystemMessage
     */
    welcomeMessages: Array<string> | null;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}. For example, to hide read conversations, use:
 *
 * `inbox.setFeedFilter({ hasUnreadMessages: true })`.
 *
 * To show everything (ie to disable the filter), use an empty object:
 *
 * `inbox.setFeedFilter({})`.
 *
 * @noinline
 * @public
 */
export declare interface ConversationPredicate {
    /**
     * Only select conversations that the current user as specific access to.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * The operand must be either a string (one of `"ReadWrite"`, `"Read"` or `"None"`) or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to remove conversations that the user has no access to anymore, do:
     * { access: ["!=", "None"] }
     * ```
     */
    access?: FieldPredicate<ConversationAccessLevel>;
    /**
     * Only select conversations that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom conversation data that you set (by passing
     * `custom` to {@link ConversationBuilder.setAttributes}). It is not necessary for all
     * conversations to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your conversations:
     *
     * ```js
     * // only show conversations that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // only show conversations of category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // only show conversations either category "shoes" or "sandals"
     * { custom: { category: ["oneOf", ["shoes", "sandals"] ] } }
     *
     * // only show conversations about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Set this field to only select conversations that have, or don't have any, unread messages.
     */
    hasUnreadMessages?: boolean;
}

/** @public
 *
 * This represents the interface of the event triggered from {@link Inbox.onConversationSelected}.
 */
export declare interface ConversationSelectedEvent {
    /**
     * The current TalkJS User
     */
    me: UserData;
    /**
     * The other participants in the conversation that are not the current user
     */
    others?: Array<UserData>;
    /**
     * The current conversation object
     */
    conversation: ConversationData | null;
}

/**
 * @public
 * Used to store additional metadata on users, conversations and messages
 */
export declare interface CustomData {
    /**
     * Any number of key/value pairs of your choosing to be stored along with the associated resource.
     * You can use custom data for all kinds of purposes, such as customizing a user's email notification text, transmitting contextual user data, or making email login tokens.
     *
     * Both the key and the value must be strings; arbitrarily deeply nested JSON is not supported. Example:
     *
     * ```
     * {"country":"nl", "itemId": "720"}
     * ```
     */
    [key: string]: string;
}

/** @public */
export declare type CustomFieldPredicate = FieldPredicate<string> | "exists" | "!exists";

/**
 * Sent by {@link Session.onDesktopNotificationClicked} when a user clicks on a browser notification.
 *
 * @public
 */
export declare interface DesktopNotificationClickedEvent {
    conversation: ConversationData;
}

/**
 * @public
 * This event is triggered when {@link https://talkjs.com/docs/Features/Notifications/Browser_Notifications.htm | desktop notifications} are toggled.
 */
export declare interface DesktopNotificationToggledEvent {
    /**
     * Boolean indicating if desktop Notifications are enabled or not
     */
    isEnabled: boolean;
}

/**
 * @public
 */
export declare enum ErrorCode {
    NOTIFICATIONS_PERMISSION_DENIED = 0,
    NOTIFICATIONS_NOT_SUPPORTED = 1,
    ARGUMENT_INVALID = 2
}

/** @public */
export declare type FieldPredicate<T> = ["==" | "!=", T] | ["oneOf" | "!oneOf", T[]];

/**
 * @public
 * @hidden due to being empty
 */
declare interface FocusEvent_2 {
}
export { FocusEvent_2 as FocusEvent }

/**
 *  @public
 *  @hidden
 */
export declare interface FullStoryOptions {
    /**
     * Fullstory hostname
     */
    host?: string;
    /**
     * Fullstory organization ID
     */
    org: string;
}

/**
 * Retrieves global App metadata.
 *
 * @remarks This function may be called before instantiating a Talk.Session, and
 * is not authenticated. Please consider all app metadata (eg global custom
 * fields) to be public data, and ensure that you do not store any sensitive
 * data in app custom fields.
 *
 * You can change App metadata using the TalkJS REST API.
 *
 * Note that this function cannot be used to verify whether an app ID exists; it
 * always returns valid data, even for nonexistent app IDs.
 */
export declare function getAppMetadata(appId: string): Promise<AppMetadata>;

/**
 * @public
 */
declare interface GetOrStartOptionsA {
    topicId?: string;
    /** Only used if `topicId` is given: a human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     */
    subject?: string;
    /** Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     */
    custom?: {
        [name: string]: string;
    };
    /** Photo to be used for this conversation in the TalkJS UI. */
    photoUrl?: string;
    welcomeMessages?: string[];
}

declare interface GetOrStartOptionsB {
    participants: Array<User>;
    /** Only used if `topicId` is given: a human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     */
    subject?: string;
    /** Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     */
    custom?: {
        [name: string]: string;
    };
    /** Photo to be used for this conversation in the TalkJS UI. */
    photoUrl?: string;
}

/**
 * HTML Panel
 * HTML panels should only be created through {@link Inbox.createHtmlPanel}, {@link Chatbox.createHtmlPanel} or {@link Popup.createHtmlPanel}.
 * @public
 */
export declare interface HtmlPanel {
    /**
     * Shows the panel if it's hidden.
     */
    show(): void;
    /**
     * Hides the panel if it's visible.
     */
    hide(): void;
    /**
     * Changes the panel height.
     *
     * @remarks
     * If you don't need to change the height after the panel is created, you can pass it as an option to the `createHtmlPanel`.
     */
    setHeight(height: number): void;
    /**
     * Returns `true` if the panel is visible, `false` if it's hidden or destroyed
     */
    isVisible(): boolean;
    /**
     * Destroys the HTML panel
     */
    destroy(): Promise<void>;
}

/** @public */
export declare interface HtmlPanelOptions {
    /**
     * Required. URL you want to load inside the HTML panel.
     * Url can be absolute ("https://www.example.com/register-form.html") or relative ("register-form.html").
     * We recommend using same origin pages to have better control of the page.
     * Learn more about HTML Panels and same origin pages {@link https://talkjs.com/docs/Customizations/HTML_Panels.html | here}.
     */
    url: string;
    /**
     * Optional, defaults to 100 (px).
     */
    height?: number;
    /**
     * Optional, defaults to true. Set false if you don't want the HTML panel to be shown after
     * `createHtmlPanel` is called. You can change the visibility of the HTML panels by
     * calling `.hide()` or `.show()` on the `HtmlPanel` instance returned by `createHtmlPanel`'s promise.
     */
    show?: boolean;
    /**
     * Either a `Conversation` object
     * (as returned from `getOrCreateConversation`) or the `id` field of
     * a conversation (which you may have stored in your database).
     * If given the HTML panel called will only show up for that conversation.
     */
    conversation?: Conversation | ConversationBuilder | string;
}

/**
 * The main messaging UI. Chats on the left, messages on the right.
 * Create an Inbox through {@link Session.createInbox} and then call {@link Inbox.mount} to show it.
 * @public
 */
export declare interface Inbox extends UIBox {
    /**
     * Controls which conversations are shown in the conversation feed
     *
     * @remarks
     * Lets you filter conversations in the conversation list, depending on access level, custom
     * conversation attributes or message read status.
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also set the filter in {@link Session.createInbox} using
     * {@link InboxOptions.feedFilter}.
     *
     * @param filter - A predicate object that controls which conversations are shown.
     */
    setFeedFilter(filter: ConversationPredicate): void;
    /**
     * Renders the Inbox UI inside a DOM element on your page
     *
     * @remarks
     * The container element specified by `container` must either be a DOM Element (as returned by e.g.
     * `document.getElementById`) or a JQuery object with a single element.
     */
    mount(container: HTMLElement | JQuery | null): Promise<void>;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onSelectConversation} instead.
     */
    on(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onConversationSelected} instead.
     */
    on(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onDesktopNotificationToggled} instead.
     */
    on(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onFocus} instead.
     */
    on(eventType: "focus", handler: (event: FocusEvent_2) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onBlur} instead.
     */
    on(eventType: "blur", handler: (event: BlurEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.translationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyupEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onSelectConversation} instead.
     */
    off(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onConversationSelected} instead.
     */
    off(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onDesktopNotificationToggled} instead.
     */
    off(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyupEvent) => void): void;
    /**
     * Triggers when a user clicks a conversation in the conversation list.
     *
     * @remarks
     * This event is triggered *before* a conversation is selected.
     * You can prevent the conversation from being actually selected by calling `event.preventDefault()`.
     */
    onSelectConversation(handler: (event: SelectConversationEvent) => void): Subscription;
    /**
     * Triggers after a conversation is selected
     *
     * @remarks
     * This event is emitted in 4 situations:
     *
     * 1. When the Inbox loads;
     *
     * 2. When the user clicks on a conversation in the feed;
     *
     * 3. When something in your code calls {@link Inbox.select}
     *
     * 4. When the Inbox is shown in mobile view, and the user clicks the `< Inbox` button.
     *
     * Note that the event's `conversation` field will be `null` when the inbox loads (and the user
     * has no conversations), when calling {@link Inbox.select} with `null` to deselect any
     * conversation, and in case 4 above.
     */
    onConversationSelected(handler: (event: ConversationSelectedEvent) => void): Subscription;
    /**
     * Triggers when the user toggles the "Desktop Notifications" toggle in the inbox conversation list header.
     */
    onDesktopNotificationToggled(handler: (event: DesktopNotificationToggledEvent) => void): Subscription;
    /**
     * Destroys the inbox and removes it from the DOM
     *
     * @remarks
     * Destroys the inbox, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the inbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Inbox
 * @public
 */
export declare interface InboxOptions extends ChatboxOptions {
    /**
     *  Makes the inbox start up with the given Conversation. Can be passed a value of the type ConversationBuilder (returned by getOrCreateConversation) or the string value of the conversation id. Conversation can be deselected on startup by passing a null value. Passing undefined means that the last conversation (or "no chats yet page") will be displayed.
     */
    selected?: Conversation | ConversationBuilder | string | null;
    /**
     * Controls if the feed header containing the toggle to enable desktop notifications is shown.
     * Defaults to true.
     */
    showFeedHeader?: boolean;
    /**
     * Controls how a chat is displayed in the feed of chats.
     *
     * Note: when set to `"subject"` but a conversation has no subject set, then
     * TalkJS falls back to `"participants"`.
     *
     * When not set, defaults to `"auto"`, which means that in group conversations
     * that have a subject set, the subject is displayed and otherwise the participants.
     *
     * (also see {@link this.chatSubtitleMode} and {@link this.chatTitleMode})
     */
    feedConversationTitleMode?: "participants" | "subject" | "auto";
    /**
     * Controls whether the user navigating between conversation should count
     * as steps in the browser history. Defaults to true, which means that if the user
     * clicks the browser's back button, they go back to the previous conversation
     * (if any).
     */
    useBrowserHistory?: boolean;
    /**
     * Used to control which conversations are shown in the conversation feed, depending on access
     * level, custom conversation attributes or message read status.
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link Inbox.setFeedFilter}.
     */
    feedFilter?: ConversationPredicate;
    /**
     * Whether to show a "Back" button at the top of the chat screen on mobile devices.
     */
    showMobileBackButton?: boolean;
}

/**
 * @public
 * @hidden due to being empty
 */
export declare interface JQuery {
    [index: number]: HTMLElement;
    length: number;
    jquery: string;
}

/**
 * Emitted through {@link Chatbox.onKeyup} when the user presses a key.
 * All fields except `isInputFocused` precisely match the corresponding fields in the browser's
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
 */
export declare interface KeyupEvent {
    /**
     * True if the event was triggered while an element was focused that can handle keyboard events.
     */
    isInputFocused: boolean;
    altKey: boolean;
    code: string;
    ctrlKey: boolean;
    key: string;
    location: number;
    metaKey: boolean;
    shiftKey: boolean;
}

/**
 * @public
 * A TalkJS message, used as part of {@link Session.onMessage}
 */
export declare interface Message {
    /**
     * The message's ID.
     */
    id: string;
    /**
     * Contains the {@link ConversationData} that the message belongs to.
     */
    conversation: ConversationData;
    /**
     * 'true' if the message was sent by the current user.
     */
    isByMe: boolean;
    /**
     * The senderID (userID) for the person that sent the message
     */
    senderId: string | null;
    /**
     * The {@link User} that sent the message
     */
    sender: UserData | null;
    /**
     * Contains the message's content
     */
    body: string;
    /**
     * Specifies if if the message is media (file), text or a shared location
     */
    type: "media" | "text" | "location";
    /**
     * UNIX timestamp specifying when the message was sent (UTC, in milliseconds)
     */
    timestamp: number;
    /**
     * 'true' if the message has been read, 'false' has not been seen yet
     */
    read: boolean;
    /**
     * Determines how this message was sent: respectively, Via a web browser (or mobile Webview), via the REST API, via reply-to-email, or using the import API.
     */
    origin: string;
    /**
     * Custom metadata that is stored with the conversation
     */
    custom: CustomData;
    /**
     * Only given if the message's `type` equals `"media"`. An object with the URL and filesize (in bytes) of the given file.
     */
    attachment: {
        url: string;
        size: number;
    } | null;
    /**
     * Only given if the message's `type` equals `"location"`. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location: [number, number] | null;
}

export declare interface MessageActionEvent {
    action: string;
    message: Message;
}

/**
 * Encapsulates the message entry field tied to the currently selected conversation.
 * @public
 */
export declare interface MessageField {
    /**
     * Focuses the message entry field.
     *
     * @remarks
     * Note that on mobile devices, this will cause the on-screen keyboard to pop up, obscuring part
     * of the screen.
     */
    focus(): void;
    /**
     * Sets the message field to `text`.
     *
     * @remarks
     * Useful if you want to guide your user with message suggestions. If you want to start a UI
     * with a given text showing immediately, call this method before calling {@link Inbox.mount}
     *
     * @param text - The text to be displayed in the message entry field
     */
    setText(text: string): void;
    /**
     * Types the given `text` into the message field.
     *
     * @remarks
     * Inserts `text` wherever the cursor currently is.
     *
     * This method may be useful for various bot/simulation scenarios. Additionally, it lets you make
     * it so that any regular keypress lets the user start typing into the message field, even if it
     * is not focused.
     *
     * To do that, capture the keypress using a regular window event listener, ensure that the user
     * isn't typing into a different input, and then call this method to type the key, followed by
     * {@link MessageField.focus}. Note that TalkJS already does this out-of-the box when the chat UI
     * iframe has focus and {@link ChatboxOptions.captureKeyboardEvents} is off.
     *
     * @param text - The text to be inserted in the message entry field
     */
    typeText(text: string): void;
    /**
     * Gets the current content of the message field.
     */
    getText(): Promise<string>;
    /**
     * Sets the visibility of the Message Field to a given value or to a certain predicate.
     *
     * @remarks
     * See {@link MessageFieldOptions.visible} for examples.
     *
     * @param visible - boolean or a more advanced predicate.
     */
    setVisible(visible: boolean | ConversationPredicate): void;
}

/**
 * @public
 */
export declare interface MessageFieldOptions {
    /**
     * If set to `true`, pressing the enter key sends the message (if there is text in the message
     * field). When set to `false`, the only way to send a message is by clicking or touching the
     * "Send" button. Defaults to `true`.
     */
    enterSendsMessage?: boolean;
    /**
     * Specifies whether the
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#attr-spellcheck | spellcheck}
     * attribute is set on the message field. Note that setting this to `true` may also enable
     * autocorrect on some mobile devices. Defaults to `false`.
     */
    spellcheck?: boolean;
    /**
     * Overrides the "placeholder" in the message field, which displays a dimmed text when no text has yet been entered.
     *
     * Defaults to "Say something..." (or a {@link https://talkjs.com/docs/Features/Multiple_Languages.html | translation thereof}).
     */
    placeholder?: string;
    /**
     * Determines whether the message field is visible. Pass either a boolean (`false` to hide it),
     * or a {@link ConversationPredicate}. The latter approach lets you show/hide the message field
     * based on properties of the current conversation.
     *
     * For example, to hide the message field when the current user has no write access to the
     * current conversation, do the following:
     *
     * ```js
     * // this predicate holds iff the current user's `access` to the current conversation is
     * // set to "ReadWrite"`:
     * const showMessageField = { access: ["==", "ReadWrite"] };
     * session.createInbox(conversation, { messageField: { visible: showMessageField } });
     * ```
     *
     * Defaults to `true`.
     */
    visible?: boolean | ConversationPredicate;
    /**
     * Determines whether the message field should automatically focus when the user navigates.
     *
     * Defaults to "smart", which means that the message field gets focused whenever a conversation
     * is selected, if possible without negative side effects. I.e. only when:
     *
     * - The message field is inside the browser viewport (so focusing will not unexpectedly cause
     *   the page to scroll)
     *
     * - The user is likely on a desktop/laptop computer (so focusing will not unexpectedly expand a
     *   mobile on-screen keyboard).
     *
     * Note: If you need more control, consider setting `autofocus` to false and calling
     * {@link MessageField.focus} at appropriate times.
     */
    autofocus?: false | "smart";
}

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}. For example, to hide all system messages (eg only show user messages), do:
 *
 * `chatbox.setMessageFilter({type: ["==", "UserMessage"]})`
 *
 * To show all messages (ie disable the filter), just pass an empty object:
 *
 * `chatbox.setMessageFilter({})`
 *
 * @noinline
 * @public
 */
export declare interface MessagePredicate {
    /**
     * Only show messages that are sent by a sender that has all of the given properties
     *
     * For example:
     *
     * ```js
     * // Only show messages sent by users with the role of 'admin' and if the user ID is 1.
     * {sender: {role: ["==", "admin"], id: ["==", "1"]}}
     * ```
     */
    sender?: {
        id?: FieldPredicate<string>;
        custom?: {
            [key: string]: CustomFieldPredicate;
        };
        locale?: FieldPredicate<string>;
        role?: FieldPredicate<string>;
    };
    /**
     * Only show messages of a given type, for example:
     *
     * ```js
     * {type: ["==", "SystemMessage"]}
     * ```
     *
     */
    type?: FieldPredicate<"UserMessage" | "SystemMessage">;
    /**
     * Only show messages that were sent by users (web), through the REST API (rest), via
     * reply-to-email (email) or via the import REST API (import).
     *
     * For example:
     *
     * ```js
     * // Don't show messages that were sent via the REST API
     * { origin: ["!=", "rest"] }
     * ```
     *
     */
    origin?: FieldPredicate<"web" | "rest" | "email" | "import">;
    /**
     * Only select messages that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom message data that you have set. It is not necessary for all
     * messages to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your messages:
     *
     * ```js
     * // Only show messages that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // Only show messages of that have the category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // Only show messages that have the 'topic' either "inquiry" or "reservation"
     * { custom: { topic: ["oneOf", ["inquiry", "reservation"] ] } }
     *
     * // Only show messages about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
}

/**
 * A helper method to predictably compute a Conversation ID based on participants' ids in the given conversation.
 * Use this method if you want to simply create a conversation between two users,
 * not related to a particular product, order or transaction.
 *
 * The order of the parameters does not matter.
 * For example, `Talk.oneOnOneId("a", "b")` yields the same result as `Talk.oneOnOneId("b", "a")`.
 *
 * This method takes the following steps:
 * 1. Take two ids of users and put them in an array
 * 2. Sort them lexicographically
 * 3. JSON encode them
 * 4. hash the result using SHA1, return the first 20 characters
 *
 * In pseudocode, this is what this function does:
 *
 *     var sorted = [me.id, other.id].sort()
 *     var encoded = JSON.encode(sorted)
 *     var hash = sha1(encoded)             // as lowercase hex
 *     return truncate(hash, 20)
 *
 * For a PHP implementation, see https://gist.github.com/eteeselink/4dc3ad32cc478986ff2b5b6361a1825f.
 * {@link https://talkjs.com/?chat | Get in touch} if you need our help implementing this in your backend language.
 * @public
 */
export declare function oneOnOneId(me: User | string, other: User | string): string;

/**
 * @public
 * @hidden due to being empty
 */
export declare interface OpenEvent {
}

/**
 * @public
 * @hidden
 * Contains information about an individual participant
 */
export declare interface Participant {
    /**
     * A Talk JS {@link User}
     */
    readonly user: User;
    /**
     * Contains access and notification settings for a given user's participation to a given conversation. Used in ConversationBuilder.setParticipant.
     */
    readonly participationSettings: Partial<ParticipationSettings>;
}

/**
 * Specifies access and notification settings for a given user's participation
 * to a given conversation. Used in {@link ConversationBuilder.setParticipant}.
 * @public
 */
export declare interface ParticipationSettings {
    /**
     * Specifies the participant's access permission for a conversation. See {@link ConversationBuilder.setParticipant}
     */
    access?: "Read" | "ReadWrite";
    /**
     * Specifies the participants's notification settings. See {@link ConversationBuilder.setParticipant}
     */
    notify?: boolean;
}

/**
 * A messaging UI for just a single conversation.
 *
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Popup.select}).
 * Create a Popup through {@link Session.createPopup} and then call
 * {@link Popup.mount} to show it.
 * @public
 */
export declare interface Popup extends UIBox {
    /**
     * Renders the Popup UI on your page
     *
     * @remarks
     * Loads the popup in the background, but by default shows only the launcher button. Pass
     * `{ show: true }` to open the popup as soon as it's loaded.
     */
    mount(options?: {
        show?: boolean;
    }): Promise<void>;
    /**
     * Destroys the popup and removes it from the DOM
     *
     * @remarks
     * Destroys the popup, removes it from the DOM and removes all event listeners it has running.
     */
    destroy(): void;
    /**
     * Shows the Popup
     *
     * @remarks
     * Use this to show a popup that was previously hidden or mounted with a parameter `show: false`.
     * Note: does nothing on unmounted popups. Make sure you call {@link mount} once before you call `show()` or {@link hide}.
     */
    show(): void;
    /**
     * Closes the popup, but doesn't remove it from the DOM
     */
    hide(): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onOpen} instead.
     */
    on(eventType: "open", handler: (event: OpenEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onClose} instead.
     */
    on(eventType: "close", handler: (event: CloseEvent_2) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onFocus} instead.
     */
    on(eventType: "focus", handler: (event: FocusEvent_2) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onBlur} instead.
     */
    on(eventType: "blur", handler: (event: BlurEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onTranslationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyupEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("open")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onOpen} instead.
     */
    off(eventType: "open", handler: (event: OpenEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("close")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onClose} instead.
     */
    off(eventType: "close", handler: (event: CloseEvent_2) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("keyup")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyupEvent) => void): void;
    /**
     * Triggers when the popup is opened by the user
     *
     * @remarks
     * Only gets triggered when the user performs an action to open the popup.
     * This event is not triggered when you call {@link Popup.show} or when you
     * {@link Popup.mount} it with the `{show: true}` option.
     */
    onOpen(handler: (event: OpenEvent) => void): Subscription;
    /**
     * Triggers when the popup is closed by the user
     *
     * @remarks
     * Only gets triggered when the user performs an action to close the popup,
     * eg when they click the "X" on the launcher or,
     * {@link PopupOptions.showCloseInHeader | if enabled}, in the popup header.
     * This event is not triggered when you call {@link Popup.hide} or
     * {@link Popup.destroy}.
     */
    onClose(handler: (event: CloseEvent_2) => void): Subscription;
}

/**
 * @alias UIBox Popup
 * @public
 */
export declare interface PopupOptions extends ChatboxOptions {
    /**
     * If enabled, the Popup will reopen every time
     * the user navigates to another page. This way, a conversation can continue
     * while the user browses around. Set to `false` to disable this behavior.
     *
     * Defaults to false.
     */
    keepOpen?: boolean;
    /**
     * Specifies whether to show a round
     * launcher and/or close button beneath the popup in the right bottom corner
     * of the page.
     *
     * @remarks
     * `"close-only"`: show a close button beneath the popup, but don't show a launch button
     *
     * `"always"`: show a launch button when the popup is closed, show a close button when it is visible
     *
     * `"never"`: never show a launcher
     *
     * Note: if you choose `"never"` you may want to override the positioning of the popup as well.
     * Just tune the `__talkjs_popup` class in your CSS.
     *
     * Ignored on mobile, where the popup fills the entire screen so the value is effectively `"never"`.
     *
     * Defaults to `"always"`.
     *
     */
    launcher?: "close-only" | "always" | "never";
    /**
     * Whether to show the "x" icon in the popup header to close the popup.
     * "auto", which is the default value means `true` on mobile and to `false` on desktop.
     */
    showCloseInHeader?: boolean | "auto";
}

/** @public */
export declare const ready: Promise<void>;

/**
 * @public
 * Event data triggered from {@link Inbox.onSelectConversation}.
 */
export declare interface SelectConversationEvent {
    /**
     * The current TalkJS User
     */
    me: UserData;
    /**
     * The other participants in the conversation that are not the current user
     */
    others: Array<UserData>;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * Prevents the clicked conversation from being selected.
     */
    preventDefault(): void;
}

/**
 * @public
 * The event triggered when listening for the sendMessage event on the {@link Inbox}, {@link Chatbox} and {@link Popup}.
 * This event is triggered before the message is sent to TalkJS, allowing you to modify the contents of the message or its metadata by
 * using `override()`.
 */
export declare interface SendMessageEvent {
    /**
     * The message that was sent
     */
    message: SentMessage;
    /**
     * The current TalkJS user
     */
    me: UserData;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * This function allows you to modify the contents of the message or its metadata before the message is sent
     */
    override: ({ text, custom }: {
        text?: string;
        custom?: CustomData;
    }) => void;
}

/**
 * @public
 */
export declare interface SendMessageOptions {
    /**
     * An object with any custom data that you may wish to associate with this message. The custom data is sent back to you via webhooks and the REST API.
     */
    custom?: CustomData;
}

/**
 * @public
 * A message that was sent to TalkJS
 */
export declare interface SentMessage {
    /**
     * The message ID of the message that was sent
     */
    id: string | undefined;
    /**
     * The ID of the conversation that the message belongs to
     */
    conversationId: string;
    /**
     * Identifies the message as either a {@link https://talkjs.com/docs/Reference/Concepts/Messages.html | User message} or
     * {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | System message}
     */
    type: "UserMessage" | "SystemMessage";
    /**
     * Contains an Array of {@link User.id}'s that have read the message
     */
    readBy: string[];
    /**
     * Contains the user ID for the person that sent the message
     */
    senderId: string;
    /**
     * Contains the message's text
     */
    text?: string;
    /**
     * Only given if the message contains a file. An object with the URL and filesize (in bytes) of the given file.
     */
    attachment?: {
        url: string;
        size: number;
    };
    /**
     * Only given if the message contains a location. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location?: [number, number];
}

/**
 * A session represents a user's active browser tab. It also authenticates your app
 * with TalkJS.
 *
 * @public
 */
export declare class Session {
    private readonly _eventEmitter;
    private _uiBoxes;
    private _alive;
    /**
     * Holds information about unread conversations. Lets your app be notified
     * when the active user receives a new message.
     */
    readonly unreads: Unreads;
    /** The TalkJS {@link User} associated with the current user in your application. */
    readonly me: User;
    /** Your TalkJS `AppId` that can be found your TalkJS {@link https://talkjs.com/dashboard | dashboard}. */
    readonly appId: string;
    private readonly _sessionId;
    /**
     * Creates a TalkJS Session.
     * @public
     */
    constructor(options: SessionOptions);
    /**
     * Verifies whether the `appId` is valid.
     *
     * @remarks
     * Returns a Promise of a boolean, never rejects.
     */
    hasValidCredentials(): Promise<boolean>;
    private _maybeRestorePopup;
    private _trackWindowFocus;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * Returns a `Conversation` object that encapsulates a conversation
     * between `me` (given in the constructor) and `other`.
     *
     * @param other - A `User` object that identifies the person to converse with.
     * The user is uniquely identified by their id; all other fields (name, photo
     * etc) are overwritten in the TalkJS database each  time they change.
     * @param options - Options used for getOrStartConversation
     */
    getOrStartConversation(other: User, options?: GetOrStartOptionsA): Conversation;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * Returns a `Conversation` object that encapsulates a conversation between `me` (given in the
     * constructor) and zero or more other `participants`.
     *
     * @param conversationId - A unique identifier for this conversation. Any user with access to
     *                         this ID can join this conversation.
     *
     * @param options - Options used for getOrStartConversation
     *
     */
    getOrStartConversation(conversationId: string, options?: GetOrStartOptionsB): Conversation;
    private _maybeAddMyParticipant;
    /**
     * A method used to either fetch or create a conversation.
     *
     * @remarks
     * Returns a `ConversationBuilder` object that encapsulates a conversation
     * between `me` (given in the constructor) and zero or more other `participants`.
     * Use {@link ConversationBuilder.setParticipant} and {@link ConversationBuilder.setAttributes}
     * on the returned object to further set up your conversation.
     *
     * @param conversationId - A unique identifier for this conversation, such as a channel name or topic ID.
     * Any user with access to this ID can join this conversation. {@link https://talkjs.com/docs/Reference/Concepts/Conversations.html | Read about how to choose a good conversation ID for your use case}.
     * If you want to make a simple one-on-one conversation, consider using {@link oneOnOneId} to generate one.
     */
    getOrCreateConversation(conversationId: string): ConversationBuilder;
    /**
     * Creates an Inbox UI
     *
     * @remarks
     * The Inbox is the main UI component of TalkJS. It shows a user's conversation
     * history and it allows them to write messages. You typically want to call the
     * `mount` method after creating the Inbox to make it visible on your app.
     *
     * Call `createInbox` on the messaging page of your app.
     *
     * @param options - Optional. Use these to finetune the behavior of the Inbox.
     */
    createInbox(options?: InboxOptions): Inbox;
    /**
     * Creates a Chatbox UI.
     *
     * @remarks
     * The Chatbox is a slimmer version of the Inbox. It shows a single conversation,
     * without means to switch between conversations. In order to select a conversation inside a Chatbox
     * you need to call {@link Chatbox.select}.
     *
     * Example:
     * js```
     * const chatbox = session.createChatbox();
     * chatbox.select(conversation);
     * ```
     *
     * You typically want to call {@link mount} after creating the Chatbox to make it visible on your app.
     *
     *
     * Call `createChatbox` on any page you want to show a chatbox of a single conversation.
     *
     * Note: A deprecated two-parameter form of this method, `createChatbox(selectedConversation, options)`, also exists. This form will keep being supported but we recommend not using it new codebases. Instead, call {@link Chatbox.select} immediately after `mount`.
     *
     * @param options - Optional, Use these to finetune the behavior of the Chatbox.
     */
    createChatbox(options?: ChatboxOptions): Chatbox;
    /**
     *  @public
     *  @deprecated
     *  @hidden
     */
    createChatbox(conversation: Conversation | ConversationBuilder | null | undefined, options?: ChatboxOptions): Chatbox;
    /**
     * @public
     * @deprecated
     * @hidden
     */
    createPopup(conversation: Conversation | ConversationBuilder | null | undefined, options?: PopupOptions): Popup;
    /**
     * Creates a Popup UI.
     *
     * @remarks
     * The Popup is a positioned box containing a conversation. It shows a single conversation,
     * without means to switch between conversations.
     * In order to select a conversation inside a Popup
     * you need to call the {@link Popup.select}.
     *
     * Example:
     * js```
     * const popup = session.createPopup();
     * popup.select(conversation);
     * ```
     *
     * You typically want to call the `mount` method after creating the popup to make it visible on your app.
     *
     *
     * Call `createPopup` on any page you want to show a popup of a single conversation.
     *
     * Note: A deprecated two-parameter form of this method, `createChatbox(selectedConversation, options)`, also exists. This form will keep being supported but we recommend not using it new codebases. Instead, call {@link Chatbox.select} immediately after `mount`.
     * In order to have a popup on each site you need to call
     * `createPopup` on any page you want to show a popup with the conversation.
     *
     * @param options - Optional, Use these to finetune the behavior of the Popup.
     */
    createPopup(options?: PopupOptions): Popup;
    /**
     * Used to configure TalkJS to use a theme hosted on the same location as your application for development.
     *
     * @remarks
     * Tells TalkJS to use a theme hosted on the same location as your application (e.g. localhost:8000/).
     * e.g. Call `talkSession.syncThemeForLocalDev("/assets/css/talkjs-theme.css")`
     * just before you call `createInbox` or `createChatbox`. TalkJS will then use the specified file instead of using a theme created in the dashboard.
     *
     * @param path - The path to the theme's CSS file
     */
    syncThemeForLocalDev(path: string): void;
    /**
     * Sets desktop notification on or off.
     *
     * @remarks
     * Has the same effect as toggling the "Desktop notification" toggle in the
     * TalkJS Inbox UI. Use this function to replicate that toggle elsewhere in
     * your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * When desktop notifications are enabled for the first time, the browser
     * will show a prompt to ask the user for permission. The call will only
     * succeed if the user accepts it.
     *
     * We recommend only calling this function in response to user action, so
     * users know that they can expect a permission prompt. This significantly
     * increases the percentage of users that click "Allow".
     *
     * Notably, we strongly recommend that you do not call this function
     * immediately when the page loads, because many browsers auto block
     * notifications when permission is requested on page load. This is likely a
     * measure to prevent overly aggressive news sites from being able to spam
     * past visitors.
     *
     * @param isEnabled - Whether notifications should be enabled.
     * @param alertOnFailure - Whether to show an alert message when enabling
     * notifications fails.
     *
     * @returns a promise that'll resolve if the change succeeds, but rejects if
     * anything goes wrong. If anything goes wrong, the promise will be rejected
     * with a {@link TalkError}, which has a `code` property. Possible values
     * for it are:
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_PERMISSION_DENIED`: The browser or the
     *   user didn't grant you permission to send notifications.
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_NOT_SUPPORTED`: The browser doesn't
     *   support desktop notifications.
     */
    setDesktopNotificationEnabled(isEnabled: boolean, { alertOnFailure }?: {
        alertOnFailure?: boolean;
    }): Promise<void>;
    private _cleanUIBoxes;
    /**
     * Registers mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.unregisterDevice | Session.unregisterDevice}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    registerDevice({ platform, pushRegistrationId, }: {
        platform: "ios" | "android";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     * Unregisters mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.registerDevice | Session.registerDevice}
     */
    unregisterDevice(): Promise<void>;
    private _onNotificationClick;
    /**
     * Listens for an event
     *
     * @remarks
     * A `"message"` event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * For an example, see {@link https://gist.github.com/eteeselink/607e585eb40be76f2ed150d4090e5261}
     *
     * Note that this event does not get triggered for conversations where the current user is a {@link https://talkjs.com/docs/Features/Group_Chats/Super_Group_Chats/#guest-access-limitations | guest}.
     * It only applies to users who were added as participants.
     *
     * Related method: {@link Session.off}
     *
     * @deprecated Please use {@link Session.onMessage} instead.
     */
    on(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Listens for an event
     *
     * @remarks
     * A `"desktopNotificationClicked"` event is fired every time a user clicks on a desktop notification
     * generated by TalkJS.
     *
     * When a user clicks on a notification, these things will happen:
     *
     * 1. The browser tab will be selected (note, this works in most browsers but cannot be guaranteed);
     *
     * 2. If you provided one or more "desktopNotificationClicked" handlers, they will be invoked in order;
     *
     * 3. If you did not, then the currently active inbox (if any) will jump to the conversation corresponding to the notification.
     *
     * See also {@link this.setDesktopNotificationEnabled} and {@link Session.off}
     *
     * @deprecated Please use {@link Session.onDesktopNotificationClicked} instead.
     */
    on(eventType: "desktopNotificationClicked", handler: (event: DesktopNotificationClickedEvent) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events.
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Session.onMessage} instead.
     */
    off(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events.
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Session.onDesktopNotificationClicked} instead.
     */
    off(eventType: "desktopNotificationClicked", handler: (event: DesktopNotificationClickedEvent) => void): void;
    /**
     * Triggered when a message is sent in a conversation the current user is in.
     *
     * @remarks
     * A `"message"` event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * Note that this event does not get triggered for conversations where the current user is a {@link https://talkjs.com/docs/Features/Group_Chats/Super_Group_Chats/#guest-access-limitations | guest}.
     * It only applies to users who were added as participants.
     *
     */
    onMessage(handler: (message: Message) => void): Subscription;
    /**
     * Listen for when a user clicks a desktop notification.
     *
     * @remarks
     * A `"desktopNotificationClicked"` event is fired every time a user clicks on a desktop notification
     * generated by TalkJS.
     *
     * When a user clicks on a notification, these things will happen:
     *
     * 1. The browser tab will be selected (note, this works in most browsers but cannot be guaranteed);
     *
     * 2. If you provided one or more "desktopNotificationClicked" handlers, they will be invoked in order;
     *
     * 3. If you did not, then the currently active inbox (if any) will jump to the conversation corresponding to the notification.
     *
     * See also {@link this.setDesktopNotificationEnabled}
     *
     * @deprecated Please use {@link Session.onDesktopNotificationClicked} instead.
     */
    onDesktopNotificationClicked(handler: (message: Message) => void): Subscription;
    /**
     * Disconnects all websockets, removes all UIs, and invalidates this session.
     *
     * @remarks
     * You cannot use any objects that were created in this session after you destroy it.
     *
     * If you want to use TalkJS after having called `destroy()` you must instantiate a new
     * Talk.Session instance.
     */
    destroy(): void;
    /**
     * Returns a list of all active {@link Popup} objects linked to this
     * session.
     *
     * @remarks
     * Includes popups actively created using {@link createPopup}, and also
     * popups created on page load, if {@link PopupOptions.keepOpen} was set to
     * `true` on an earlier page.
     *
     * Only includes popups that are still mounted in the DOM. So if you call
     * `createPopup()` but later remove its container element (or an ancestor of
     * the container), then the `Popup` object will have been made invalid and
     * is therefore not included in the results.
     */
    getPopups(): Popup[];
    /**
     * Returns a list of all active {@link Inbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes inboxes that are still mounted in the DOM. So if you call
     * `createInbox()` but later remove its container element (or an ancestor of
     * the container), then the `Inbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getInboxes(): Inbox[];
    /**
     * Returns a list of all active {@link Chatbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes chatboxes that are still mounted in the DOM. So if you call
     * `createChatbox()` but later remove its container element (or an ancestor of
     * the container), then the `Chatbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getChatboxes(): Chatbox[];
}

/**
 * @public
 */
export declare interface SessionOptions {
    /** Your app's unique TalkJS id. Get it from the dashboard. */
    appId: string;
    /**
     * A `User` object that identifies the currently active user.
     * The user is uniquely identified by their id; all other fields
     * (name, photo, etc) are overwritten in the TalkJS database each
     * time they change, unless the user has been created with the alternate
     * constructor. */
    me: User;
    /**
     * If you use
     * {@link https://talkjs.com/docs/Features/Identity_Verification.html | Identity verification}
     * make sure you generate and use a signature.
     */
    signature?: string;
}

/**
 * A subscription to an event
 * @public
 */
export declare interface Subscription {
    /**
     * Stop receiving events for this subscription
     */
    unsubscribe(): void;
}

/**
 * TalkJS Error class, inherits from the global Error class.
 *
 * @remarks
 * TalkJS methods may throw (or reject promises with) instances of this class
 * if specific catchable information can be provided through the `code` property.
 *
 * @public
 */
export declare class TalkError extends Error {
    /**
     * Machine-readable error code
     */
    code: ErrorCode;
    /**
     * Human-readable error message
     */
    message: string;
}

/**
 * @public
 * Used to configure supported third-party integrations with TalkJS. See
 * {@link https://talkjs.com/docs/Features/Customizations/Third_Party_Integrations.html | third party integrations }
 *
 */
export declare interface ThirdPartyOptions {
    fullstory?: FullStoryOptions;
}

/**
 * @public
 * This event is triggered when the user toggles real-time message translation using the built-in toggle.
 */
export declare interface TranslationToggledEvent {
    /**
     * Boolean indicating if translation is enabled or not
     */
    isEnabled: boolean;
    /**
     * Conversation for which translation has been toggled
     */
    conversation: ConversationData;
}

/**
 * @public
 * @hidden
 */
export declare interface UIBox {
    /**
     * Switches the active conversation the conversation.
     *
     * @remarks
     * `conversation` can be either a {@link ConversationBuilder} object or a TalkJS
     * conversation id. Passing `null` means that the conversation will be de-selected in the UI and the message list will disappear.
     * Passing `undefined` means that the last conversation (or "no chats yet" page if there are no other conversations) will be rendered in the message list component.
     */
    select(conversation: string | Conversation | ConversationBuilder | null | undefined): void;
    /**
     * Switches the active conversation the conversation.
     *
     * @remarks
     * `conversation` can be either a {@link ConversationBuilder} object or a TalkJS
     * conversation id. Passing `null` means that the conversation will be de-selected in the UI and the message list will disappear.
     * Passing `undefined` means that the last conversation (or "no chats yet" page if there are no other conversations) will be rendered in the message list component.
     *
     * @param params - Selection parameters. `asGuest` can be used to select the conversation as a guest, with limited functions
     */
    select(conversation: string | Conversation | ConversationBuilder | null | undefined, params?: {
        asGuest?: boolean;
    }): void;
    /**
     * Encapsulates the message entry field tied to the currently selected conversation.
     */
    messageField: MessageField;
    /**
     * Listens for an event.
     *
     * Triggers when the user sends a message using the TalkJS UI
     * @deprecated Please use {@link Chatbox.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere inside the chat UI.
     *
     * @deprecated Please use {@link Chatbox.onFocus} instead.
     */
    on(eventType: "focus", handler: (event: FocusEvent_2) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere outside the chat UI.
     *
     * @deprecated Please use {@link Chatbox.onBlur} instead.
     */
    on(eventType: "blur", handler: (event: BlurEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Triggers when the user toggles translation in a conversation
     * @deprecated Please use {@link Chatbox.onTranslationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * This event is only emitted when {@link ChatboxOptions.captureKeyboardEvents} is enabled. In
     * that case, it is emitted for every keypress, including regular letters typed into text fields.
     *
     * `event.isInputFocused` is true when a TalkJS input area is focused (eg the message field, the
     * search box, or adjacent buttons). When this is the case, keypresses are likely to cause changes
     * inside the chat UI. We recommend that you discard these events except when implementing global
     * shortcuts that should take effect regardless of whether the user is typing a message or
     * otherwise interacting with the chat UI using the keyboard.
     *
     * Note: by design, TalkJS does not handle special multi-key shortcuts other than those provided
     * by the user's device (eg ctrl+v for paste). This means that it is usually safe to assign
     * special behavior to unused keyboard shortcuts with one or more modifier keys (like alt, shift
     * or ctrl), even when `isInputFocused` is true.
     *
     * All other event fields are the same as the corresponding fields in the browser's
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
     *
     * @example
     * ```ts
     * myChatbox.on("keyup", event => {
     *   if(event.shiftKey || event.altKey || event.metaKey) {
     *     return;
     *   }
     *   if(!event.isInputFocused && event.key === "1") {
     *     // let the 1 key switch to our app's main panel, except if the user is typing
     *     myApp.selectMainPanel();
     *   }
     *   if(event.ctrlKey && event.key === "q") {
     *     // quit if the user hits ctrl+q, irrespective of whether they're typing.
     *     myApp.quit();
     *   }
     * });
     * ```
     *
     * @deprecated Please use {@link Chatbox.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyupEvent) => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyupEvent) => void): void;
    /**
     * Triggers when a user launches a custom action within the TalkJS UI.
     *
     * @remarks
     * To set up a custom action, you need to create it in the role editor. If an action is allowed on a particular message, it'll show up in that message's action menu.
     * The name you specify when setting up the action, is also the name you should pass in here (case sensitive).
     * The event you get contains information about the message on which the action was called, including its ID, so you can look it up later via our REST API.
     * @param action the action you want to listen for
     * @param handler the handler to be called
     * @returns a subscription you can use to unsubscribe.
     */
    onCustomMessageAction(action: string, handler: (event: MessageActionEvent) => void): Subscription;
    /**
     * Triggers when the user sends a message using the TalkJS UI
     */
    onSendMessage(handler: (event: SendMessageEvent) => void): Subscription;
    /**
     * Triggers when the chat UI is focussed.
     */
    onFocus(handler: () => void): Subscription;
    /**
     * Triggers when focus moves out of the chat UI.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere outside the chat UI.
     */
    onBlur(handler: () => void): Subscription;
    /**
     * Triggers when the user toggles message translation in the TalkJS UI.
     */
    onTranslationToggled(handler: (event: TranslationToggledEvent) => void): Subscription;
    /**
     * Triggers a {@link KeyupEvent} when the user releases a key.
     *
     * @remarks
     * This event is only emitted when {@link ChatboxOptions.captureKeyboardEvents} is enabled. In
     * that case, it is emitted for every keypress, including regular letters typed into text fields.
     *
     * `event.isInputFocused` is true when a TalkJS input area is focused (eg the message field, the
     * search box, or adjacent buttons). When this is the case, keypresses are likely to cause changes
     * inside the chat UI. We recommend that you discard these events except when implementing global
     * shortcuts that should take effect regardless of whether the user is typing a message or
     * otherwise interacting with the chat UI using the keyboard.
     *
     * Note: by design, TalkJS does not handle special multi-key shortcuts other than those provided
     * by the user's device (eg ctrl+v for paste). This means that it is usually safe to assign
     * special behavior to unused keyboard shortcuts with one or more modifier keys (like alt, shift
     * or ctrl), even when `isInputFocused` is true.
     *
     * All other event fields are the same as the corresponding fields in the browser's
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
     *
     * @example
     * ```ts
     * myChatbox.onKeyup(event => {
     *   if(event.shiftKey || event.altKey || event.metaKey) {
     *     return;
     *   }
     *   if(!event.isInputFocused && event.key === "1") {
     *     // let the 1 key switch to our app's main panel, except if the user is typing
     *     myApp.selectMainPanel();
     *   }
     *   if(event.ctrlKey && event.key === "q") {
     *     // quit if the user hits ctrl+q, irrespective of whether they're typing.
     *     myApp.quit();
     *   }
     * });
     * ```
     */
    onKeyup(handler: (event: KeyupEvent) => void): Subscription;
    /**
     * Puts custom HTML just above the message field.
     *
     * @remarks
     * Using HTML Panels, you can extend TalkJS UIs to have anything from credit card payments to lead
     * collection forms, or, for instance, to show the product details of a marketplace transaction
     * between your users. See our
     * {@link https://talkjs.com/docs/Features/Customizations/HTML_Panels.html | HTMLPanels documentation}
     * for more info.
     */
    createHtmlPanel(options: HtmlPanelOptions): Promise<HtmlPanel>;
    /**
     * Sets metadata for the current session.
     *
     * @param params - Object with presence parameters.
     *
     * - `visible` manually sets the information about the visibility of TalkJS.
     *   This is useful when TalkJS is hidden with CSS. TalkJS will assume that UIs
     *   marked `visible: false` cannot be seen, and thus messages arriving on this UI will
     *   not be marked as read until you set `visible` to true again.
     *
     * - `custom` is an additional parameter to store the custom fields, that you
     *   may want to use in the REST API call.
     */
    setPresence(params: {
        visible?: boolean;
        custom?: {
            [key: string]: string;
        };
    }): void;
    /**
     * Destroys the component and removes it from the DOM
     *
     * @remarks
     * Destroys the component, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the the component container from the DOM.
     */
    destroy(): void;
    /**
     * Toggles desktop notifications
     *
     * @remarks
     * This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.setDesktopNotificationEnabled}.
     *
     * Sets desktop notification on or off. Has the same effect as toggling the
     * "Desktop notification" toggle in the TalkJS Inbox UI. Use this function to replicate that
     * toggle elsewhere in your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * @deprecated Please use {@link Session.setDesktopNotificationEnabled} instead.
     */
    toggleDesktopNotifications(isEnabled: boolean): void;
    /**
     * Used to control which messages are shown in the message list
     *
     * @remarks
     * Lets you filter messages depending on a type, origin or custom message attributes.
     *
     * <b>Note</b>: Messages are only filtered in the message list. The inbox UI's conversation feed will
     * always show the last message sent to the conversation, regardless of the message filter set.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * @example
     * ```ts
     * // only show messages sent by users with role "admin"
     * chatbox.setMessageFilter({
     *   sender: {
     *     role: ["==", "admin"],
     *   }
     * });
     * ```
     *
     * @param filter - A predicate object that controls which messages are shown.
     */
    setMessageFilter(filter: MessagePredicate): void;
    /**
     * Enable or disable translation for a conversation.
     *
     * @param conversation - The conversation for which this should be set. If not specified, the setting will be applied to the currently selected conversation.
     * @param enabled - Whether translation should be enabled
     */
    setTranslationEnabledForConversation(conversation: string | ConversationBuilder, enabled: boolean): void;
    /**
     * Enable/disable translation by default.
     *
     * @remarks
     * This setting is applied to any conversation for which you haven't set a specific value.
     *
     * @param enabled - Whether conversations should be translated by default or not. Pass "auto" to
     *                  enable translation for conversations with users with different locales.
     */
    setTranslationEnabledDefault(enabled: boolean | "auto"): void;
    /**
     * Highlights certain words in messages
     *
     * @remarks
     * The TalkJS search feature includes the ability to highlight certain words in messages. Call
     * this method to highlight certain words without having the user invoke the search feature.
     * Call again with an empty array to disable highlighting.
     *
     * Note: like the search feature, this option only works on the Growth plan and up.
     *
     * Also see {@link ChatboxOptions.highlightedWords}
     */
    setHighlightedWords(words: string[]): void;
}

/**
 * @public
 * Used as part of {@link Unreads.on}.
 */
export declare interface UnreadConversation {
    /**
     * Contains the last {@link Message} for an unread conversation.
     */
    lastMessage: Message;
}

/**
 * This object can notify you when the amount of unread conversations changes.
 * You can't instantiate it - instead, get an instance via {@link Session.unreads}.
 *
 * @public
 */
export declare interface Unreads {
    /**
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * @remarks
     * Note that conversations where the user is a {@link https://talkjs.com/docs/Features/Group_Chats/Super_Group_Chats/#guest-access-limitations | guest}
     * do not keep track of unread messages. This is only done for users who are added as participants.
     *
     * Related methods: {@link Unreads.off}
     *
     * @deprecated Please use {@link Unreads.onChange} instead.
     */
    on(eventType: "change", handler: (messages: UnreadConversation[]) => void): void;
    /**
     * Call this with the same `eventType` and `handler` that you used for `on` to
     * stop receiving events.
     *
     * @remarks
     * Related methods: {@link Unreads.on}
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Unreads.onChange} instead.
     */
    off(eventType: "change", handler: (messages: UnreadConversation[]) => void): void;
    /**
     * Triggered when the list of unread conversations changes.
     *
     * @remarks
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * Note that conversations where the user is a {@link https://talkjs.com/docs/Features/Group_Chats/Super_Group_Chats/#guest-access-limitations | guest}
     * do not keep track of unread messages. This is only done for users who are added as participants.
     */
    onChange(handler: (messages: UnreadConversation[]) => void): Subscription;
}

/**
 * A user of your app. TalkJS uses the `id` to uniquely identify this user.
 * All other fields of a User are allowed to vary over time and the TalkJS database will update its fields accordingly.
 * @public
 */
export declare class User {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    readonly id: string;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    readonly name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     */
    readonly email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     */
    readonly phone?: string | Array<string> | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    readonly welcomeMessage?: string | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    readonly photoUrl?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    readonly role?: string | null;
    /**
     * @deprecated Please use {@link User.role} instead.
     */
    readonly configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    readonly custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    readonly availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Multiple_Languages.html | localization documentation}.
     */
    readonly locale?: string | null;
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Use this constructor to synchronize user data with the TalkJS backend.
     *
     * The fields `id`, `name` and `email` are required.
     * A warning will be emitted if `role` is not specified.
     *
     * Set `email` to `null` if you want to use TalkJS without email fallback.
     */
    constructor(options: UserOptions);
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Only use this constructor if you're sure
     * that a user by the given `id` already exists in TalkJS (for instance, because you
     * synchronized it via the REST API). Otherwise use the `new User(options: object):` constructor instead.
     */
    constructor(id: string | number);
}

/**
 * @public
 */
export declare interface UserData {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    welcomeMessage: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role: string | null;
    /**
     * @deprecated Please use {@link UserData.role} instead.
     */
    configuration: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    custom: CustomData;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    availabilityText: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Multiple_Languages.html | localization documentation}.
     */
    locale: string | null;
}

/**
 * @public
 */
export declare interface UserOptions {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     */
    email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     */
    phone?: string | Array<string> | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl?: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    welcomeMessage?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role?: string | null;
    /**
     * @deprecated Please use {@link UserOptions.role} instead.
     */
    configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Multiple_Languages.html | localization documentation}.
     */
    locale?: string | null;
}

export { }
