{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\n\nfunction useUncontrolled(_ref) {\n  let {\n    value,\n    defaultValue,\n    finalValue,\n    rule,\n    onChange,\n    onValueUpdate\n  } = _ref;\n  const shouldBeControlled = rule(value);\n  const modeRef = useRef(\"initial\");\n  const initialValue = rule(defaultValue) ? defaultValue : finalValue;\n  const [uncontrolledValue, setUncontrolledValue] = useState(initialValue);\n  let effectiveValue = shouldBeControlled ? value : uncontrolledValue;\n\n  if (!shouldBeControlled && modeRef.current === \"controlled\") {\n    effectiveValue = finalValue;\n  }\n\n  modeRef.current = shouldBeControlled ? \"controlled\" : \"uncontrolled\";\n  const mode = modeRef.current;\n\n  const handleChange = nextValue => {\n    typeof onChange === \"function\" && onChange(nextValue);\n\n    if (mode === \"uncontrolled\") {\n      setUncontrolledValue(nextValue);\n    }\n  };\n\n  useEffect(() => {\n    if (mode === \"uncontrolled\") {\n      setUncontrolledValue(effectiveValue);\n    }\n\n    typeof onValueUpdate === \"function\" && onValueUpdate(effectiveValue);\n  }, [mode, effectiveValue]);\n  return [effectiveValue, handleChange, modeRef.current];\n}\n\nexport { useUncontrolled };","map":{"version":3,"sources":["D:\\D-Downlods\\MINI_ Prpject 2022\\lab-manage-sys\\node_modules\\@mantine\\hooks\\src\\use-uncontrolled\\use-uncontrolled.ts"],"names":[],"mappings":";;AACO,SAAS,eAAT,OAOJ;AAAA,MAP6B;AAC9B,IAAA,KAD8B;AAE9B,IAAA,YAF8B;AAG9B,IAAA,UAH8B;AAI9B,IAAA,IAJ8B;AAK9B,IAAA,QAL8B;AAM9B,IAAA;AAN8B,GAO7B;AACD,QAAM,kBAAkB,GAAG,IAAI,CAAC,KAAD,CAA/B;AACA,QAAM,OAAO,GAAG,MAAM,CAAC,SAAD,CAAtB;AACA,QAAM,YAAY,GAAG,IAAI,CAAC,YAAD,CAAJ,GAAqB,YAArB,GAAoC,UAAzD;AACA,QAAM,CAAC,iBAAD,EAAoB,oBAApB,IAA4C,QAAQ,CAAC,YAAD,CAA1D;AACA,MAAI,cAAc,GAAG,kBAAkB,GAAG,KAAH,GAAW,iBAAlD;;AACA,MAAI,CAAC,kBAAD,IAAuB,OAAO,CAAC,OAAR,KAAoB,YAA/C,EAA6D;AAC3D,IAAA,cAAc,GAAG,UAAjB;AACD;;AACD,EAAA,OAAO,CAAC,OAAR,GAAkB,kBAAkB,GAAG,YAAH,GAAkB,cAAtD;AACA,QAAM,IAAI,GAAG,OAAO,CAAC,OAArB;;AACA,QAAM,YAAY,GAAI,SAAD,IAAe;AAClC,WAAO,QAAP,KAAoB,UAApB,IAAkC,QAAQ,CAAC,SAAD,CAA1C;;AACA,QAAI,IAAI,KAAK,cAAb,EAA6B;AAC3B,MAAA,oBAAoB,CAAC,SAAD,CAApB;AACD;AACF,GALD;;AAMA,EAAA,SAAS,CAAC,MAAM;AACd,QAAI,IAAI,KAAK,cAAb,EAA6B;AAC3B,MAAA,oBAAoB,CAAC,cAAD,CAApB;AACD;;AACD,WAAO,aAAP,KAAyB,UAAzB,IAAuC,aAAa,CAAC,cAAD,CAApD;AACD,GALQ,EAKN,CAAC,IAAD,EAAO,cAAP,CALM,CAAT;AAMA,SAAO,CAAC,cAAD,EAAiB,YAAjB,EAA+B,OAAO,CAAC,OAAvC,CAAP;AACF","sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nexport type UncontrolledMode = 'initial' | 'controlled' | 'uncontrolled';\n\nexport interface UncontrolledOptions<T> {\n  value: T | null | undefined;\n  defaultValue: T | null | undefined;\n  finalValue: T | null;\n  onChange(value: T | null): void;\n  onValueUpdate?(value: T | null): void;\n  rule: (value: T | null | undefined) => boolean;\n}\n\nexport function useUncontrolled<T>({\n  value,\n  defaultValue,\n  finalValue,\n  rule,\n  onChange,\n  onValueUpdate,\n}: UncontrolledOptions<T>): readonly [T | null, (nextValue: T | null) => void, UncontrolledMode] {\n  // determine, whether new props indicate controlled state\n  const shouldBeControlled = rule(value);\n\n  // initialize state\n  const modeRef = useRef<UncontrolledMode>('initial');\n  const initialValue = rule(defaultValue) ? defaultValue : finalValue;\n  const [uncontrolledValue, setUncontrolledValue] = useState(initialValue);\n\n  // compute effective value\n  let effectiveValue = shouldBeControlled ? value : uncontrolledValue;\n\n  if (!shouldBeControlled && modeRef.current === 'controlled') {\n    // We are transitioning from controlled to uncontrolled\n    // this transition is special as it happens when clearing out\n    // the input using \"invalid\" value (typically null or undefined).\n    //\n    // Since the value is invalid, doing nothing would mean just\n    // transitioning to uncontrolled state and using whatever value\n    // it currently holds which is likely not the behavior\n    // user expects, so lets change the state to finalValue.\n    //\n    // The value will be propagated to internal state by useEffect below.\n\n    effectiveValue = finalValue;\n  }\n\n  modeRef.current = shouldBeControlled ? 'controlled' : 'uncontrolled';\n  const mode = modeRef.current;\n\n  const handleChange = (nextValue: T | null) => {\n    typeof onChange === 'function' && onChange(nextValue);\n\n    // Controlled input only triggers onChange event and expects\n    // the controller to propagate new value back.\n    if (mode === 'uncontrolled') {\n      setUncontrolledValue(nextValue);\n    }\n  };\n\n  useEffect(() => {\n    if (mode === 'uncontrolled') {\n      setUncontrolledValue(effectiveValue);\n    }\n    typeof onValueUpdate === 'function' && onValueUpdate(effectiveValue);\n  }, [mode, effectiveValue]);\n\n  return [effectiveValue, handleChange, modeRef.current] as const;\n}\n"]},"metadata":{},"sourceType":"module"}